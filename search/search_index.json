{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started on Earth Observation Application Packaging with CWL","text":"<p>This guide supports \"Getting started on Earth Observation Application Packaging with CWL\" tutorial events, where participants are introduced to the world of Earth Observation (EO) Application Packages and explore how to effectively package, share, and execute EO workflows using the Common Workflow Language (CWL) standard.</p> <p>This tutorial event is designed for developers, scientists, and EO enthusiasts who want to get started and increase their skills in creating and sharing EO Application Packages. </p> <p>Whether you are new to CWL or already have some experience, this event will provide valuable insights and practical knowledge to boost your expertise.</p> <p>During the event, you will learn:</p> <ul> <li>The fundamentals of EO Application Packages and their role in the EO domain.</li> <li>How to leverage CWL to describe, package, and share workflows.</li> <li>Techniques for incorporating data, code, configuration files, and documentation into an EO Application Package.</li> <li>Best practices for creating portable and reproducible EO workflows.</li> <li>Hands-on exercises to reinforce your understanding and gain practical experience.</li> </ul> <p>When developers package an EO Application, they are in fact packaging their own software, written in a specific programming language, as a containerized application (or a set of containerized applications), to be described as an EO Application Package using the Common Workflow Language as described in the OGC proposed best practices.</p> <p>To achieve this, developers follow the steps described below.</p> <ul> <li>Prepare one or more container images containing the execution dependencies of the software.</li> <li>Prepare the CWL CommandLineTool document(s) wrapping the command line tool available in container(s).</li> <li>Prepare the CWL Workflow orchestrating CWL CommandLineTool document(s) wrapping the command line tool available container(s).</li> <li>Test the application package in one or more execution scenarios.</li> </ul> <p>This tutorial will guide you through step-by-step tutorials, demonstrating the process of creating EO Application Packages using CWL with a simple EO application for water bodies detection using the Normalised Difference Water Index (NDWI). </p>"},{"location":"installation/","title":"Installation","text":"<p>This page provides guidance on how to run the hands-on modules using minikube.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Operating System: A compatible OS (Linux, macOS, or Windows). If using Windows, WSL2 is recommended for compatibility.</li> <li>Virtualization Support: Ensure virtualization is enabled in the BIOS/UEFI settings, as it's required for running Minikube or Docker.</li> </ul>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":""},{"location":"installation/#install-docker","title":"Install Docker","text":"<ul> <li>Linux: Follow Docker's installation guide.</li> <li>macOS and Windows: Install Docker Desktop.</li> </ul>"},{"location":"installation/#install-minikube","title":"Install Minikube","text":"<p>Download Minikube from the official site.</p> <p>Follow the installation instructions based on the OS.</p> <ul> <li>macOS: <code>brew install minikube</code></li> <li>Linux: Use the binary or package manager (e.g., apt for Ubuntu).</li> <li>Windows: Install using Chocolatey: <code>choco install minikube</code></li> </ul>"},{"location":"installation/#install-kubectl","title":"Install Kubectl","text":"<p>Download the <code>kubectl</code> binary from Kubernetes' official site.</p> <p>Alternatively, use a package manager:</p> <ul> <li>macOS: <code>brew install kubectl</code></li> <li>Linux: <code>sudo apt-get install -y kubectl</code> (debian based)</li> <li>Windows: <code>choco install kubernetes-cli</code></li> </ul>"},{"location":"installation/#install-skaffold","title":"Install Skaffold","text":"<p>Follow the installation steps from Skaffold\u2019s official documentation.</p> <p>Examples:</p> <ul> <li>macOS: <code>brew install skaffold</code></li> <li>Linux: Download the binary and move it to /usr/local/bin/.</li> <li>Windows: Use Chocolatey: <code>choco install skaffold</code></li> </ul>"},{"location":"installation/#install-helm","title":"Install Helm","text":"<p>Follow the installation steps from Helm's official documentation </p> <ul> <li>macOS: <code>brew install helm</code></li> <li>Linux: Follow Helm's installation guide.</li> <li>Windows: <code>choco install kubernetes-helm</code></li> </ul>"},{"location":"installation/#set-up-minikube","title":"Set Up Minikube","text":"<p>Start Minikube: <code>minikube start</code></p> <p>Verify it\u2019s running: <code>kubectl get nodes</code></p> <p>If necessary, specify a driver (e.g., Docker): <code>minikube start --driver=docker</code></p>"},{"location":"installation/#deploy-the-module","title":"Deploy the module","text":"<p>Create the namespace with: </p> <pre><code>kubectl create ns eoap-quickwin\n</code></pre> <p>Type <code>skaffold dev -p coder</code></p> <p>This prints:</p> <pre><code>No tags generated\nStarting deploy...\n - deployment.apps/code-server-deployment created\n - persistentvolumeclaim/code-server-pvc created\n - service/code-server-service created\n - configmap/init created\n - configmap/bash-rc created\n - configmap/bash-login created\n - serviceaccount/localstack created\n - role.rbac.authorization.k8s.io/localstack created\n - rolebinding.rbac.authorization.k8s.io/localstack created\n - service/localstack created\n - deployment.apps/localstack created\nWaiting for deployments to stabilize...\nDeployments stabilized in 26.042192ms\nStarting post-deploy hooks...\nWaiting for deployment and pod to be running...\nDeployment replicas: \nPod status: Pending\nWaiting for deployment and pod to be running...\nDeployment replicas: 1\nPod status: Running\nDeployment with label app=code-server is running and a pod is in Running state\nCompleted post-deploy hooks\nPort forwarding service/code-server-service in namespace eoap-quickwin, remote port 8080 -&gt; http://127.0.0.1:8001\nNo artifacts found to watch\nPress Ctrl+C to exit\nWatching for changes...\n</code></pre> <p>Open your browser on the link printed in the log </p>"},{"location":"app/water-bodies-detection/","title":"Water bodies detection","text":""},{"location":"app/water-bodies-detection/#water-bodies-detection","title":"Water bodies detection","text":"<p>This application takes as input Copernicus Sentinel-2 or USSG Landsat-9 data and detects water bodies by applying the Otsu thresholding technique on the Normalized Difference Water Index (NDWI).</p> <p>The NDWI is calculated with: </p> \\[ NDWI = { (green - nir) \\over (green + nir) }  \\] <p>Typically, NDWI values of water bodies are larger than 0.2 and built-up features have positive values between 0 and 0.2.</p> <p>Vegetation has much smaller NDWI values, which results in distinguishing vegetation from water bodies easier. </p> <p>The NDWI values correspond to the following ranges:</p> Range Description 0,2 - 1 Water surface 0.0 - 0,2 Flooding, humidity -0,3 - 0.0 Moderate drought, non-aqueous surfaces -1 - -0.3 Drought, non-aqueous surfaces <p>To ease the determination of the water surface/non water surface, the Ostu thresholding technique is used. </p> <p>In the simplest form, the Otsu algorithm returns a single intensity threshold that separate pixels into two classes, foreground and background. This threshold is determined by minimizing intra-class intensity variance, or equivalently, by maximizing inter-class variance:</p> <p></p>"},{"location":"app/water-bodies-detection/#application","title":"Application","text":"<p>The application is a Python command line tool that takes a Sentinel-2 STAC item reference applies the crop over the area of interest for the radiometric bands green and NIR, the normalized difference, the Ostu threshold and finally creates a STAC catalog and items for the generated results.</p> <p>This scenario is depicted below:</p> graph TB subgraph Process STAC item   A[STAC Item] -- STAC Item URL --&gt; B   A[STAC Item] -- STAC Item URL --&gt; C   A[STAC Item] -- STAC Item URL --&gt; F subgraph loop on bands   B[\"crop(green)\"];   C[\"crop(nir)\"]; end   B[\"crop(green)\"] -- crop_green.tif --&gt; D[Normalized difference];   C[\"crop(nir)\"] -- crop_nir.tif --&gt; D[Normalized difference];   D -- norm_diff.tif --&gt; E[Otsu threshold] end   E -- otsu.tif --&gt; F[Create STAC Catalog]   F -- \"catalog.json/item.json/asset otsu.tif\" --&gt; G[(storage)]"},{"location":"app/water-bodies-detection/#application-package","title":"Application Package","text":"<p>Alice packages the application as an Application Package to include a workflow that reads a Sentinel-2 STAC item references launches Python command line tool to detect the water bodies:</p> <p></p>"},{"location":"app/water-bodies-detection/#dataset","title":"Dataset","text":"<p>The development and test dataset is made of two Sentinel-2 acquisitions:</p> Acquisitions Mission Sentinel-2 Sentinel-2 Date 2022-05-24 2021-07-13 URL S2B_10TFK_20210713_0_L2A S2A_10TFK_20220524_0_L2A Quicklook"},{"location":"app/water_bodies/app/","title":"Description","text":""},{"location":"app/water_bodies/app/#step-purpose","title":"Step purpose","text":"<p>Purpose: to detect water bodies using the Otsu threshold on the NDWI index from a satellite image acquired by Sentinel-2. </p> <p>This step is highlighted below:</p> graph TB subgraph Process STAC item   A[STAC Item] -- STAC Item URL --&gt; B   A[STAC Item] -- STAC Item URL --&gt; C   A[STAC Item] -- STAC Item URL --&gt; F subgraph loop on bands   B[\"crop(green)\"];   C[\"crop(nir)\"]; end   B[\"crop(green)\"] -- crop_green.tif --&gt; D[Normalized difference];   C[\"crop(nir)\"] -- crop_nir.tif --&gt; D[Normalized difference];   D -- norm_diff.tif --&gt; E[Otsu threshold] end   E -- otsu.tif --&gt; F[Create STAC Catalog]   F -- \"catalog.json/item.json/asset otsu.tif\" --&gt; G[(storage)]"},{"location":"app/water_bodies/app/#code","title":"Code","text":"<p>The <code>app.py</code> script is a command-line tool that takes as input</p> <ul> <li>a SpatioTemporal Asset Catalog (STAC) Item</li> <li>a bounding box area of interest (AOI)</li> <li>an EPSG code</li> <li>a common band names as input</li> </ul> <p>and then:</p> <ul> <li>reads the STAC Item</li> <li>loops on the common band names to crop the specified band from the asset associated with the common band name to the specified AOI. </li> <li>performs a normalized difference between two cropped raster images</li> <li>applies the Otsu threshold to a single input raster image</li> <li>takes the STAC Item URL and corresponding water body GeoTIFF to create a STAC Item, and organizes it into a STAC Catalog</li> </ul> <p>It uses various Python libraries like <code>pystac</code>, <code>rasterio</code>, <code>pyproj</code>, <code>shapely</code>, and <code>loguru</code>.</p> <p>Here is an overview of the script's functionality:</p> <ul> <li> <p><code>aoi2box</code> Function: Converts an Area of Interest (AOI) expressed as a string representation of a bounding box into a list of floating-point numbers, making it compatible with geospatial operations.</p> </li> <li> <p><code>get_asset</code> Function: Retrieves a specific asset from a STAC Item using a common band name. It iterates through the STAC Item's assets to find a match based on the common name associated with a band, ensuring the relevant geospatial data is selected for processing.</p> </li> <li> <p><code>crop</code> Function: Acts as the script's core operation, initiating the process by reading the specified STAC Item from the input URL. It locates and processes the asset corresponding to the given common band name(s), applying geospatial operations to crop this asset to the designated AOI. The cropping operation is facilitated by rasterio and involves several key steps:</p> </li> <li> <p>Coordinate transformation is performed to align the AOI with the asset's coordinate reference system (CRS), based on the provided EPSG code.</p> </li> <li> <p>The rasterio.mask.mask function is used to crop the asset using the transformed bounding box, effectively isolating the area of interest from the larger dataset.</p> </li> <li> <p>The cropped image data is then written to a new GeoTIFF file, following a naming convention like \"crop_bandname.tif,\" making it straightforward to identify the output related to specific bands.</p> </li> </ul> <p>After cropping, the script  implements functionality for image processing including:</p> <ul> <li> <p>Calculating the normalized difference index (NDI) using the normalized_difference function, a common technique in remote sensing for extracting specific features from multi-band imagery, such as vegetation index or water index, depending on the bands selected.</p> </li> <li> <p>Applying Otsu's method for thresholding using the threshold function, which can be used for binary classification of the image data, such as distinguishing water bodies from other land covers.</p> </li> <li> <p>STAC Catalog Creation: In its concluding steps, the script generates a new STAC Catalog to include the processed imagery. This involves creating a catalog entry for the output data, ensuring that the geospatial data's metadata is properly organized and accessible for further use, sharing, or integration with other geospatial data systems.</p> </li> </ul> <p>The script has a command-Line Interface that uses <code>click</code> to create a user-friendly command-line interface. It allows users to input the application parameters such as the STAC Item URL, the AOI, the EPSG code for coordinate reference, and the common band name(s) for the imagery data of interest. </p> <p>The script usage is:</p> <pre><code>Usage: app.py [OPTIONS]\n\n  Detects water bodies using the Normalized Difference Water Index (NDWI) and\n  Otsu thresholding.\n\nOptions:\n  --input-item TEXT  STAC Item URL or staged STAC catalog  [required]\n  --aoi TEXT         Area of interest expressed as a bounding box  [required]\n  --epsg TEXT        EPSG code  [required]\n  --band TEXT        Common band name  [required]\n  --help             Show this message and exit.\n</code></pre> <p>To use this script, you would typically run it from the command line, providing the necessary input options such as the STAC Item URL, AOI, EPSG code, and common band name: </p> <pre><code>python app.py \\\n  --input-item \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\" \\\n  --aoi \"-121.399,39.834,-120.74,40.472\" \\\n  --epsg \"EPSG:4326\" \\\n  --band \"green\" \n</code></pre> <p>It will then crop the specified band from the STAC asset and save it as a GeoTIFF file.</p> <p>The Python code is provided here:</p> water-bodies/command-line-tools/detect-water-body/app.py<pre><code>import os\nimport click\nimport pystac\nimport rasterio\nfrom skimage.filters import threshold_otsu\nfrom rasterio.mask import mask\nfrom pyproj import Transformer\nfrom shapely import box\nfrom loguru import logger\nimport rasterio\nimport pystac\nimport shutil\nimport rio_stac\nimport numpy as np\n\nnp.seterr(divide=\"ignore\", invalid=\"ignore\")\n\n\ndef crop(asset: pystac.Asset, bbox, epsg):\n    \"\"\"_summary_\n\n    Args:\n        asset (_type_): _description_\n        bbox (_type_): _description_\n        epsg (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    with rasterio.open(asset.get_absolute_href()) as src:\n        transformer = Transformer.from_crs(epsg, src.crs, always_xy=True)\n\n        minx, miny = transformer.transform(bbox[0], bbox[1])\n        maxx, maxy = transformer.transform(bbox[2], bbox[3])\n\n        transformed_bbox = box(minx, miny, maxx, maxy)\n\n        logger.info(f\"Crop {asset.get_absolute_href()}\")\n\n        out_image, out_transform = rasterio.mask.mask(\n            src, [transformed_bbox], crop=True\n        )\n        out_meta = src.meta.copy()\n\n        out_meta.update(\n            {\n                \"height\": out_image.shape[1],\n                \"width\": out_image.shape[2],\n                \"transform\": out_transform,\n            }\n        )\n\n        return out_image.astype(np.float32), out_meta\n\n\ndef threshold(data):\n    \"\"\"Returns the Otsu threshold of a numpy array\"\"\"\n    return data &gt; threshold_otsu(data[np.isfinite(data)])\n\n\ndef normalized_difference(array1, array2):\n    \"\"\"Returns the normalized difference of two numpy arrays\"\"\"\n    return (array1 - array2) / (array1 + array2)\n\n\ndef aoi2box(aoi):\n    \"\"\"Converts an area of interest expressed as a bounding box to a list of floats\"\"\"\n    return [float(c) for c in aoi.split(\",\")]\n\n\ndef get_asset(item, common_name):\n    \"\"\"Returns the asset of a STAC Item defined with its common band name\"\"\"\n    for _, asset in item.get_assets().items():\n        if not \"data\" in asset.to_dict()[\"roles\"]:\n            continue\n\n        eo_asset = pystac.extensions.eo.AssetEOExtension(asset)\n        if not eo_asset.bands:\n            continue\n        for b in eo_asset.bands:\n            if (\n                \"common_name\" in b.properties.keys()\n                and b.properties[\"common_name\"] == common_name\n            ):\n                return asset\n\n\n@click.command(\n    short_help=\"Water bodies detection\",\n    help=\"Detects water bodies using the Normalized Difference Water Index (NDWI) and Otsu thresholding.\",\n)\n@click.option(\n    \"--input-item\",\n    \"item_url\",\n    help=\"STAC Item URL or staged STAC catalog\",\n    required=True,\n)\n@click.option(\n    \"--aoi\",\n    \"aoi\",\n    help=\"Area of interest expressed as a bounding box\",\n    required=True,\n)\n@click.option(\n    \"--epsg\",\n    \"epsg\",\n    help=\"EPSG code\",\n    required=True,\n)\n@click.option(\n    \"--band\",\n    \"bands\",\n    help=\"Common band name\",\n    required=True,\n    multiple=True,\n)\ndef main(item_url, aoi, bands, epsg):\n    if os.path.isdir(item_url):\n        catalog = pystac.read_file(os.path.join(item_url, \"catalog.json\"))\n        item = next(catalog.get_items())\n    else:\n        item = pystac.read_file(item_url)\n\n    logger.info(f\"Read {item.id} from {item.get_self_href()}\")\n\n    cropped_assets = {}\n\n    for band in bands:\n        asset = get_asset(item, band)\n        logger.info(f\"Read asset {band} from {asset.get_absolute_href()}\")\n\n        if not asset:\n            msg = f\"Common band name {band} not found in the assets\"\n            logger.error(msg)\n            raise ValueError(msg)\n\n        bbox = aoi2box(aoi)\n\n        out_image, out_meta = crop(asset, bbox, epsg)\n\n        cropped_assets[band] = out_image[0]\n\n    nd = normalized_difference(cropped_assets[bands[0]], cropped_assets[bands[1]])\n\n    water_bodies = threshold(nd)\n\n    out_meta.update(\n        {\n            \"dtype\": \"uint8\",\n            \"driver\": \"COG\",\n            \"tiled\": True,\n            \"compress\": \"lzw\",\n            \"blockxsize\": 256,\n            \"blockysize\": 256,\n        }\n    )\n\n    water_body = \"otsu.tif\"\n\n    with rasterio.open(water_body, \"w\", **out_meta) as dst_dataset:\n        logger.info(f\"Write otsu.tif\")\n        dst_dataset.write(water_bodies, indexes=1)\n\n    logger.info(f\"Creating a STAC Catalog\")\n    cat = pystac.Catalog(id=\"catalog\", description=\"water-bodies\")\n\n    if os.path.isdir(item_url):\n        catalog = pystac.read_file(os.path.join(item_url, \"catalog.json\"))\n        item = next(catalog.get_items())\n    else:\n        item = pystac.read_file(item_url)\n\n    os.makedirs(item.id, exist_ok=True)\n    shutil.copy(water_body, item.id)\n\n    out_item = rio_stac.stac.create_stac_item(\n        source=water_body,\n        input_datetime=item.datetime,\n        id=item.id,\n        asset_roles=[\"data\", \"visual\"],\n        asset_href=os.path.basename(water_body),\n        asset_name=\"data\",\n        with_proj=True,\n        with_raster=True,\n    )\n\n    cat.add_items([out_item])\n\n    cat.normalize_and_save(\n        root_href=\"./\", catalog_type=pystac.CatalogType.SELF_CONTAINED\n    )\n\n    logger.info(\"Done!\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"containers/scope/","title":"Scope","text":"<p>When developers package and EO, they are in fact packaging their own software, written in a specific programming language, as a containerized application (or a set of containerized applications), to be described as an EO Application Package using the Common Workflow Language as described in the OGC proposed best practices.</p> <p>To achieve this, developers follow the steps described below.</p> <ul> <li>Prepare one or more container images containing the execution dependencies of the software.</li> <li>Prepare the CWL CommandLineTool document(s) wrapping the command line tool available container(s).</li> <li>Prepare the CWL Workflow orchestrating CWL CommandLineTool document(s) wrapping the command line tool available container(s).</li> <li>Test the application package in one or more execution scenarios.</li> </ul>"},{"location":"containers/water_bodies/","title":"Water bodies detection","text":""},{"location":"containers/water_bodies/#goal","title":"Goal","text":"<ul> <li>Build the container image</li> <li>Run the water bodies detection in the container image tagged <code>localhost/detect-water-bodies:latest</code>.</li> </ul>"},{"location":"containers/water_bodies/#lab","title":"Lab","text":"<p>This step has a dedicated lab available at <code>/workspace/quickwin/practice-labs/Container.ipynb</code></p>"},{"location":"containers/water_bodies/#the-container-recipe","title":"The container recipe","text":"<p>The water bodies detection has a recipe to build the container image.</p> <p>The <code>detect_water_bodies</code> step container image recipe is:</p> detect-water-body/Dockerfile<pre><code>FROM docker.io/library/python:3.10-slim@sha256:80619a5316afae7045a3c13371b0ee670f39bac46ea1ed35081d2bf91d6c3dbd\n\nRUN pip install --no-cache-dir \\\n    rasterio \\\n    click \\\n    pystac \\\n    loguru \\\n    pyproj \\\n    shapely \\\n    scikit-image \\\n    pystac \\\n    rio_stac &amp;&amp; \\\n    python -c \"import rasterio\"\n\nADD app.py /app/app.py\n\nENTRYPOINT []\n</code></pre>"},{"location":"containers/water_bodies/#building-the-container","title":"Building the container:","text":"<p>Build the container images with:</p> terminal<pre><code>export WORKSPACE=/workspace/quickwin\n\ncommand -v podman &gt;/dev/null 2&gt;&amp;1 &amp;&amp; { \n\n    podman build --format docker -t localhost/detect-water-body:latest ${WORKSPACE}/water-bodies/command-line-tools/detect-water-body\n\n} || command -v docker &gt;/dev/null 2&gt;&amp;1 &amp;&amp; { \n\n    docker build -t localhost/detect-water-body:latest ${WORKSPACE}/water-bodies/command-line-tools/detect-water-body \n}\n</code></pre>"},{"location":"containers/water_bodies/#expected-outcome","title":"Expected outcome","text":"<p>The local container registry lists the built images:</p> <pre><code>(base) jovyan@coder-mrossi:~/runs$ podman images | grep localhost\nlocalhost/detect-water-body  latest      534f3f10c06e  11 minutes ago  530 MB\n</code></pre>"},{"location":"containers/water_bodies/#how-to-run-a-step-in-a-container","title":"How to run a step in a container","text":"<p>We'll use <code>podman</code> container engine (<code>docker</code> is also fine).</p> <p>The command to run the <code>detect-water-body</code> step in the container is:</p> <pre><code>podman run \\\n    -i \\\n    --userns=keep-id \\\n    --mount=type=bind,source=/workspace/quickwin/runs,target=/runs \\\n    --workdir=/runs \\\n    --read-only=true \\\n    --user=1001:100 \\\n    --rm \\\n    --env=HOME=/runs \\\n    --env=PYTHONPATH=/app \\\n    localhost/detect-water-body:latest \\\n    python \\\n    -m \\\n    app \\\n    --aoi \\\n    \"-121.399,39.834,-120.74,40.472\" \\\n    --band \\\n    green \\\n    --band \\\n    nir \\\n    --epsg \\\n    \"EPSG:4326\" \\\n    --input-item \\\n    https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\n</code></pre> <p>Let's break down what this command does:</p> <ul> <li><code>podman run</code>: This is the command to run a container.</li> <li><code>-i</code>: This flag makes the container interactive, allowing you to interact with it via the terminal.</li> <li><code>--userns=keep-id</code>: It instructs <code>podman</code> to keep the user namespace ID. <code>--mount=type=bind,source=/workspace/runs,target=/runs</code>: This option mounts a directory from the host system to the container. In this case, it mounts the <code>/workspace/runs</code> directory on the host to the /runs directory inside the container.</li> <li><code>--workdir=/runs</code>: Sets the working directory inside the container to <code>/runs</code>.</li> <li><code>--read-only=true</code>: Makes the file system inside the container read-only, meaning you can't write or modify files inside the container.</li> <li><code>--user=1001:100</code>: Specifies the user and group IDs to be used within the container.</li> <li><code>--rm</code>: This flag tells podman to remove the container after it has finished running.</li> <li><code>--env=HOME=/runs</code>: Sets the <code>HOME</code> environment variable inside the container to <code>/runs</code>.</li> <li><code>--env=PYTHONPATH=/app</code>: Sets the <code>PYTHONPATH</code> environment variable inside the container to <code>/app</code>.</li> <li><code>localhost/detect-water-body:latest</code>: This is the name of the container image that you want to run. It's pulling the image from the local container registry with the name \"detect-water-body\" and the \"latest\" tag.</li> <li><code>python -m app</code>: This is the command to run inside the container. It runs a Python module named \"app\".</li> <li><code>--aoi \"-121.399,39.834,-120.74,40.472\"</code>: This provides command-line arguments to the Python module. It specifies the area of interest (AOI) as a bounding box.</li> <li><code>--band green</code>: Specifies the band to be extracted from the Sentinel-2 acquisition. In this case, it's the \"green\" band.</li> <li><code>--band nir</code>: Specifies the band to be extracted from the Sentinel-2 acquisition. In this case, it's the \"nir\" band.</li> <li><code>--epsg \"EPSG:4326\"</code>: Specifies the EPSG code, which defines the coordinate system used for the <code>aoi</code> command-line argument.</li> <li><code>--input-item ...</code>: Specifies the input STAC item URL. This particular URL points to a Sentinel-2 image hosted on AWS Earth Search.</li> </ul>"},{"location":"containers/water_bodies/#expected-outcome_1","title":"Expected outcome","text":"<p>The folder <code>/workspace/quickwin/runs</code> contains: </p> <pre><code>(base) jovyan@jupyter-mrossi--training:~/quickwin$ tree runs/\nruns/\n\u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A\n\u2502   \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A.json\n\u2502   \u2514\u2500\u2500 otsu.tif\n\u251c\u2500\u2500 catalog.json\n\u2514\u2500\u2500 otsu.tif\n\n1 directory, 4 files\n</code></pre>"},{"location":"cwl-cli/scope/","title":"Scope","text":"<p>When developers package and EO, they are in fact packaging their own software, written in a specific programming language, as a containerized application (or a set of containerized applications), to be described as an EO Application Package using the Common Workflow Language as described in the OGC proposed best practices.</p> <p>To achieve this, developers follow the steps described below.</p> <ul> <li>Prepare one or more container images containing the execution dependencies of the software.</li> <li>Prepare the CWL CommandLineTool document(s) wrapping the command line tool available in container(s).</li> <li>Prepare the CWL Workflow orchestrating CWL CommandLineTool document(s) wrapping the command line tool available container(s).</li> <li>Test the application package in one or more execution scenarios.</li> </ul> <p>This section shows how to do the step:</p> <ul> <li>Prepare the CWL CommandLineTool document wrapping the command line tool available container.</li> </ul>"},{"location":"cwl-cli/water_bodies/","title":"Water bodies detection","text":""},{"location":"cwl-cli/water_bodies/#goal","title":"Goal","text":"<p>Wrap the water bodies detection Python command line tool as a Common Workflow Language <code>CommandLineTool</code> and execute it with a CWL runner.</p>"},{"location":"cwl-cli/water_bodies/#lab","title":"Lab","text":"<p>This step has a dedicated lab available at <code>/workspace/quickwin/practice-labs/CommandLineTool.ipynb</code></p>"},{"location":"cwl-cli/water_bodies/#how-to-wrap-a-step-as-a-cwl-commandlinetool","title":"How to wrap a step as a CWL CommandLineTool","text":"<p>The CWL document below shows the water bodies detection Python command line tool step wrapped as a CWL CommandLineTool:</p> cwl-cli/detect-water-body<pre><code>cwlVersion: v1.0\n\nclass: CommandLineTool\nid: detect-water-body\nrequirements:\n    EnvVarRequirement:\n      envDef:\n        PYTHONPATH: /app\n    ResourceRequirement:\n      coresMax: 1\n      ramMax: 512\n    DockerRequirement:\n      dockerPull: localhost/detect-water-body:latest  \nbaseCommand: [\"python\", \"-m\", \"app\"]\narguments: []\ninputs:\n  item:\n    type: string\n    inputBinding:\n        prefix: --input-item\n  aoi:\n    type: string\n    inputBinding:\n        prefix: --aoi\n  epsg:\n    type: string\n    inputBinding:\n        prefix: --epsg\n  band:\n    type:\n      - type: array\n        items: string\n        inputBinding:\n          prefix: '--band'\n\noutputs:\n  water-body:\n    outputBinding:\n        glob: .\n    type: Directory\n</code></pre> <p>Let's break down the key components of this CWL document:</p> <ul> <li><code>cwlVersion: v1.0</code>: Specifies the version of the CWL specification that this document follows.</li> <li><code>class: CommandLineTool</code>: Indicates that this CWL document defines a command-line tool.</li> <li><code>id: crop</code>: Provides a unique identifier for this tool, which can be used to reference it in workflows.</li> <li><code>requirements</code>: Specifies the requirements and dependencies of the tool. In this case, it defines the following:<ul> <li><code>InlineJavascriptRequirement</code>: This requirement allows the use of inline JavaScript expressions in the tool.</li> <li><code>EnvVarRequirement</code>: It sets environment variables. In this case, it sets the <code>PYTHONPATH</code> environment variable to \"/app.\"</li> <li><code>ResourceRequirement</code>: Specifies resource requirements for running the tool, including the maximum number of CPU cores and maximum RAM.</li> <li><code>DockerRequirement</code>: This requirement specifies the Docker container to be used. It indicates that the tool should be executed in a Docker container with the image <code>localhost/crop:latest</code>.</li> </ul> </li> <li><code>baseCommand</code>: Defines the base command to be executed in the container. In this case, it's running a Python module called \"app\" with the command <code>python -m app</code>.</li> <li><code>arguments</code>: This section is empty, meaning there are no additional command-line arguments specified here. The tool is expected to receive its arguments via the input parameters.</li> <li><code>inputs</code>: Describes the input parameters for the tool, including their types and how they are bound to command-line arguments. The tool expects the following inputs:<ul> <li><code>item</code>: A string representing the input STAC item (image) to be processed, bound to the <code>--input-item</code> argument.</li> <li><code>aoi</code>: A string representing the area of interest (AOI) as a bounding box, bound to the <code>--aoi</code> argument.</li> <li><code>epsg</code>: A string representing the EPSG code for the coordinate system, bound to the <code>--epsg</code> argument.</li> <li><code>band</code>: An array of strings representing the name of the bands to be extracted, bound to the <code>--band</code> argument.</li> </ul> </li> <li><code>outputs</code>: Specifies the tool's output. It defines an output parameter named <code>water-body</code>, which is of type <code>Directory</code>. The outputBinding section specifies that the tool is expected to produce one or more files (glob: .) as output.</li> </ul>"},{"location":"cwl-cli/water_bodies/#steps","title":"Steps","text":"<p>Clean-up the <code>/workspace/quickwin/runs</code> folder: </p> <pre><code>rm -fr /workspace/quickwin/runs/*\n</code></pre> <p>Run the CWL document using the <code>cwltool</code> CWL runner to execute the water bodies detection:</p> terminal<pre><code>export WORKSPACE=/workspace/quickwin\n\ncommand -v podman &gt;/dev/null 2&gt;&amp;1 &amp;&amp; { \n    flag=\"--podman\"\n}\n\ncwltool ${flag} \\\n    --outdir ${WORKSPACE}/runs \\\n    ${WORKSPACE}/cwl-cli/detect-water-body.cwl \\\n    --item \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\" \\\n    --aoi=\"-121.399,39.834,-120.74,40.472\" \\\n    --epsg \"EPSG:4326\" \\\n    --band \"green\" \\\n    --band \"nir\" \n</code></pre>"},{"location":"cwl-cli/water_bodies/#expected-outcome","title":"Expected outcome","text":"<p>The folder <code>/workspace/quickwin/runs</code> contains: </p> <pre><code>(base) jovyan@jupyter-fbrito--training:~/quickwin$ tree runs\nruns\n\u2514\u2500\u2500 poz7ftyy\n    \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A\n    \u2502   \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A.json\n    \u2502   \u2514\u2500\u2500 otsu.tif\n    \u251c\u2500\u2500 catalog.json\n    \u2514\u2500\u2500 otsu.tif\n\n2 directories, 4 files\n</code></pre>"},{"location":"cwl-cli/water_bodies/#extra","title":"Extra","text":"<p>The CWL runner <code>cwltool</code> allows you to do a YAML file with the parameters:</p> params.yaml<pre><code>item: https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\naoi: \"-121.399,39.834,-120.74,40.472\"\nepsg: \"EPSG:4326\"\nband: \n- green\n- nir\n</code></pre> <p>and run it with:</p> terminal<pre><code>export WORKSPACE=/workspace/quickwin\n\ncwltool \\\n    --podman \\\n    --outdir ${WORKSPACE}/runs \\\n    ${WORKSPACE}/cwl-cli/detect-water-body.cwl \\\n    ${WORKSPACE}/cwl-cli/params.yaml \n</code></pre>"},{"location":"cwl-workflow/cloud-native/","title":"Water bodies detection","text":""},{"location":"cwl-workflow/cloud-native/#goal","title":"Goal","text":"<p>Wrap the CommandLineTool with a CWL Workflow</p>"},{"location":"cwl-workflow/cloud-native/#lab","title":"Lab","text":"<p>This step has a dedicated lab available at <code>/workspace/quickwin/practice-labs/Workflow.ipynb</code></p>"},{"location":"cwl-workflow/cloud-native/#how-to-wrap-a-cwl-commandlinetool-with-a-cwl-workflow","title":"How to wrap a CWL CommandLineTool with a CWL Workflow","text":"<p>The Cloud native Workflow orchestrates the wrapped Python application command line tool as a CWL <code>CommandLineTool</code> step with input parameters:</p> <ul> <li>a SpatioTemporal Asset Catalog (STAC) Item</li> <li>a bounding box area of interest (AOI)</li> <li>the EPSG code of the bounding box area of interest</li> <li>a list of common band names ([\"green\", \"nir\"])</li> </ul> graph TB A[STAC Item URL] A --&gt; B((\"Detect water bodies\")); B --&gt; C[STAC Catalog] <p>The CWL Workflow is shown below and the lines highlighted chain the water bodies detection step:</p> app-water-body-cloud-native.cwl<pre><code>cwlVersion: v1.0\n$namespaces:\n  s: https://schema.org/\ns:softwareVersion: 1.0.0\nschemas:\n  - http://schema.org/version/9.0/schemaorg-current-http.rdf\n$graph:\n  - class: Workflow\n    id: main\n    label: Water bodies detection based on NDWI and the otsu threshold\n    doc: Water bodies detection based on NDWI and otsu threshold applied to a single Sentinel-2 COG STAC item\n    requirements: []\n    inputs:\n      aoi:\n        label: area of interest\n        doc: area of interest as a bounding box\n        type: string\n      epsg:\n        label: EPSG code\n        doc: EPSG code\n        type: string\n        default: \"EPSG:4326\"\n      bands:\n        label: bands used for the NDWI\n        doc: bands used for the NDWI\n        type: string[]\n        default: [\"green\", \"nir\"]\n      item:\n        doc: Reference to a STAC item\n        label: STAC item reference\n        type: string\n    outputs:\n      - id: stac_catalog\n        outputSource:\n          - node_detect/stac-catalog\n        type: Directory\n    steps:\n      node_detect:\n        run: \"#detect-water-body\"\n        in:\n          item: item\n          aoi: aoi\n          epsg: epsg\n          band: bands\n        out:\n          - stac-catalog\n  - class: CommandLineTool\n    id: detect-water-body\n    requirements:\n        InlineJavascriptRequirement: {}\n        EnvVarRequirement:\n          envDef:\n            PYTHONPATH: /app\n        ResourceRequirement:\n          coresMax: 1\n          ramMax: 512\n    hints:\n      DockerRequirement:\n        dockerPull: localhost/detect-water-body:latest\n    baseCommand: [\"python\", \"-m\", \"app\"]\n    arguments: []\n    inputs:\n      item:\n        type: string\n        inputBinding:\n            prefix: --input-item\n      aoi:\n        type: string\n        inputBinding:\n            prefix: --aoi\n      epsg:\n        type: string\n        inputBinding:\n            prefix: --epsg\n      band:\n        type:\n          - type: array\n            items: string\n            inputBinding:\n              prefix: '--band'\n\n    outputs:\n      stac-catalog:\n        outputBinding:\n            glob: .\n        type: Directory\n</code></pre> <p>To run this CWL document, one does:</p> terminal<pre><code>export WORKSPACE=/workspace/quickwin\n\ncommand -v podman &gt;/dev/null 2&gt;&amp;1 &amp;&amp; { \n    flag=\"--podman\"\n}\n\ncwltool ${flag} \\\n    --outdir ${WORKSPACE}/runs \\\n    ${WORKSPACE}/cwl-workflow/app-water-body-cloud-native.cwl \\\n    --item \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\" \\\n    --aoi=\"-121.399,39.834,-120.74,40.472\" \\\n    --epsg \"EPSG:4326\" \\\n    --band \"green\" \\\n    --band \"nir\" \n</code></pre>"},{"location":"cwl-workflow/cloud-native/#expected-outcome","title":"Expected outcome","text":"<p>The folder <code>/workspace/quickwin/runs</code> contains: </p> <pre><code>(base) jovyan@jupyter-fbrito--training:~/quickwin$ tree runs\nruns\n\u2514\u2500\u2500 jtv7v57e\n    \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A\n    \u2502   \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A.json\n    \u2502   \u2514\u2500\u2500 otsu.tif\n    \u251c\u2500\u2500 catalog.json\n    \u2514\u2500\u2500 otsu.tif\n\n2 directories, 4 files\n</code></pre>"},{"location":"cwl-workflow/scope/","title":"Scope","text":"<p>When developers package and EO, they are in fact packaging their own software, written in a specific programming language, as a containerized application (or a set of containerized applications), to be described as an EO Application Package using the Common Workflow Language as described in the OGC proposed best practices.</p> <p>To achieve this, developers follow the steps described below.</p> <ul> <li>Prepare one or more container images containing the execution dependencies of the software.</li> <li>Prepare the CWL CommandLineTool document(s) wrapping the command line tool available in container(s).</li> <li>Prepare the CWL Workflow orchestrating CWL CommandLineTool document(s) wrapping the command line tool available container(s).</li> <li>Test the application package in one or more execution scenarios.</li> </ul> <p>This section shows how to do the step:</p> <ul> <li>Prepare the CWL Workflow orchestrating CWL CommandLineTool document(s) wrapping the command line tool available container(s).</li> </ul>"},{"location":"cwl-workflow/scope/#orchestrating-cwl-commandlinetools","title":"Orchestrating CWL CommandLineTools","text":"<p>The CWL <code>CommandLineTool</code>s wrapping the water bodies detection command-line tools had a single CWL class.</p> <p>An Application Package must include at least one CWL <code>Workflow</code> class orchestrating the CWL <code>CommandLineTool</code> above.</p> <p>We will need a CWL document with a list of process objects: a <code>Workflow</code> class and CWL <code>CommandLineTool</code> wrapping the Python command line tool. </p> <p>A <code>$graph</code> document does not have a process object at the root. Instead there is a <code>$graph</code> field which consists of a list of process objects.</p> <p>Each process object must have an <code>id</code> field: </p> <pre><code>cwlVersion=1.0\n\n$graph:\n- class: Workflow\n  id: main\n  ...\n\n- class: CommandLineTool\n  id: detect-water-body\n  ...\n</code></pre> <p>Workflow run fields cross-reference other processes in the document <code>$graph</code> using the <code>id</code> of the process object:</p> <pre><code>cwlVersion=1.0\n\n$graph:\n- class: Workflow\n  id: main\n  steps:\n    node_detect:\n      run: \"#detect-water-body\"\n      ...\n  ...\n\n- class: CommandLineTool\n  id: detect-water-body\n  ...\n</code></pre> <p>We propose the Workflow <code>app-water-body-cloud-native.cwl</code> reading a STAC Item as input and orchestrating the Python command line tool.</p>"},{"location":"exec/cloud-native/","title":"Sentinel-2","text":""},{"location":"exec/cloud-native/#goal","title":"Goal","text":"<p>Run the <code>app-water-body-cloud-native.1.0.0.cwl</code> released application package using <code>cwltool</code>.</p>"},{"location":"exec/cloud-native/#lab","title":"Lab","text":"<p>This step has a dedicated lab available at <code>/workspace/quickwin/practice-labs/Execution-scenario.ipynb</code></p>"},{"location":"exec/cloud-native/#step-1-configure-the-workspace","title":"Step 1 - Configure the workspace","text":"<p>The results produced will be available in the local folder <code>/workspace/quickwin/runs</code></p> terminal<pre><code>export WORKSPACE=/workspace/quickwin\nexport RUNTIME=${WORKSPACE}/runs\nmkdir -p ${RUNTIME}\ncd ${RUNTIME}\n</code></pre>"},{"location":"exec/cloud-native/#step-2-download-the-released-application-package","title":"Step 2 - Download the released Application package","text":"scripts/download-app-water-body-cloud-native.sh<pre><code>version=\"1.0.0\"\n\nexport WORKSPACE=/workspace/quickwin\n\nwget \\\n    -O ${WORKSPACE}/runs/app-water-body-cloud-native.${version}.cwl \\\n    https://github.com/eoap/quickwin/releases/download/${version}/app-water-body-cloud-native.${version}.cwl\n</code></pre>"},{"location":"exec/cloud-native/#step-3-execute-the-application-package","title":"Step 3 - Execute the Application Package","text":"scripts/exec-app-water-body-cloud-native.sh<pre><code>version=\"1.0.0\"\n\nexport WORKSPACE=/workspace/quickwin\n\ncwltool \\\n    --podman \\\n    --outdir ${WORKSPACE}/runs \\\n    ${WORKSPACE}/runs/app-water-body-cloud-native.${version}.cwl \\\n    --item \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\" \\\n    --aoi=\"-121.399,39.834,-120.74,40.472\" \\\n    --epsg \"EPSG:4326\"\n</code></pre>"},{"location":"exec/cloud-native/#expected-outcome","title":"Expected outcome","text":"<p>The folder <code>/workspace/quickwin/runs</code> contains: </p> <pre><code>(base) jovyan@jupyter-fbrito--training:~/quickwin$ tree runs\nruns\n\u251c\u2500\u2500 app-water-body-cloud-native.1.0.0.cwl\n\u2514\u2500\u2500 fc2e52v2\n    \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A\n    \u2502   \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A.json\n    \u2502   \u2514\u2500\u2500 otsu.tif\n    \u251c\u2500\u2500 catalog.json\n    \u2514\u2500\u2500 otsu.tif\n\n2 directories, 5 files\n</code></pre>"},{"location":"exec/scope/","title":"Scope","text":"<p>When developers package and EO, they are in fact packaging their own software, written in a specific programming language, as a containerized application (or a set of containerized applications), to be described as an EO Application Package using the Common Workflow Language as described in the OGC proposed best practices.</p> <p>To achieve this, developers follow the steps described below.</p> <ul> <li>Prepare one or more container images containing the execution dependencies of the software.</li> <li>Prepare the CWL CommandLineTool document(s) wrapping the command line tool available in container(s).</li> <li>Prepare the CWL Workflow orchestrating CWL CommandLineTool document(s) wrapping the command line tool available container(s).</li> <li>Test the application package in one or more execution scenarios.</li> </ul> <p>This page covers the step:</p> <p>Test the application package in one or more execution scenarios</p>"},{"location":"prerequisites/cwl/","title":"Introduction to CWL","text":"<p>The paper Methods Included: Standardizing Computational Reuse and Portability with the Common Workflow Language provides an excellent description of the Common Workflow Language project producing free and open standards for describing command-line tool based workflows.</p>"},{"location":"prerequisites/cwl/#tldr","title":"TL;DR","text":"<p>Although the paper provides a clear and concise description of the CWL standards, here's a light summary wrapping up the main points to provide the required concepts behind this guide.</p>"},{"location":"prerequisites/cwl/#cwl-key-insights","title":"CWL Key Insights","text":"<ol> <li> <p>CWL is a set of standards for describing and sharing computational workflows.</p> </li> <li> <p>The CWL standards are used daily in many science and engineering domains, including by multi-stakeholder teams.</p> </li> <li> <p>The CWL standards use a declarative syntax, facilitating polylingual workflow tasks. By being explicit about the run-time environment and any use of software containers, the CWL standards enable portability and reuse. </p> </li> <li> <p>The CWL standards provide a separation of concerns between workflow authors and workflow platforms.</p> </li> <li> <p>The CWL standards support critical workflow concepts like automation, scalability, abstraction, provenance, portability, and reusability. </p> </li> <li> <p>The CWL standards are developed around core principles of community and shared decision-making, re-use, and zero cost for participants.</p> </li> <li> <p>The CWL standards are provided as freely available open standards, supported by a diverse community in collaboration with industry, and is a Free/Open Source Software ecosystem </p> </li> </ol>"},{"location":"prerequisites/cwl/#cwl-features","title":"CWL Features","text":"<p>The CWL standard support polylingual and multi-party workflows and includes two main components:</p> <ol> <li> <p>A standard for describing command line tools</p> </li> <li> <p>A standard for describing workflows that compose such tool descriptions</p> </li> </ol> <p>The CWL standards define an explicit language with a textual syntax derived from YAML</p>"},{"location":"prerequisites/cwl/#cwl-command-line-tool-description-standard","title":"CWL Command Line Tool Description Standard","text":"<p>The CWL Command Line Tool Description Standard describes:</p> <ul> <li>how a particular command line tool works: what are the inputs and parameters and their types</li> <li>how to add the correct flags and switches to the command line invocation </li> <li>where to find the output files</li> </ul>"},{"location":"prerequisites/cwl/#cwl-workflow-description-standard","title":"CWL Workflow Description Standard","text":"<p>The CWL Workflow Description Standard is based on the same textual syntax derived from YAML to explicit workflow level inputs, outputs and steps.</p> <p>Steps are comprised of CWL CommandLineTools or CWL sub-workflows, each re-exposing their tool\u2019s required inputs. </p> <p>Inputs for each step are connected by referencing the name of either the common workflow inputs or particular outputs of other steps.</p> <p>The workflow outputs expose selected outputs from workflow steps.</p> <p>Being CWL a set of standards, the workflows are executed using a CWL runner and there are several implementations of such runners. </p> <p>This guide uses the CWL runner cwltool.</p>"},{"location":"prerequisites/cwl/#recommendations","title":"Recommendations","text":"<ul> <li> <p>Include documentation and labels for all components to enable the automatic generation of helpful visual depictions for any given CWL description</p> </li> <li> <p>Include metadata about the tool  </p> </li> <li> <p>Include a Workflow class for all CommandLineTools (a single step Workflow)</p> </li> <li> <p>Organize your CWL files is several individual files to ease their readability and maintenance. Pack your multi-file CWL Workflows (<code>cwltool --pack</code>) when needed</p> </li> </ul>"},{"location":"prerequisites/cwl/#references","title":"References","text":"<ul> <li>Crusoe, M. R. et al. Methods Included: Standardizing Computational Reuse and Portability with the Common Workflow Language, retrieved from https://arxiv.org/abs/2105.07028</li> </ul>"},{"location":"prerequisites/yaml/","title":"Introduction to YAML","text":""},{"location":"prerequisites/yaml/#key-value-pairs","title":"Key-Value Pairs","text":"<p>Fundamentally, a file written in YAML consists of a set of key-value pairs.</p> <p>Each pair is written as <code>key: value</code>, where whitespace after the <code>:</code> is optional.</p> <p>Key names in CWL files should not contain whitespace - We use camelCase for multi-word key names that have special meaning in the CWL specification and underscored key names otherwise.</p> <p>For example:</p> <pre><code>first_name: Bilbo\nlast_name:  Baggins\nage_years:  111\nhome:       Bag End, Hobbiton\n</code></pre> <p>The YAML above defines four keys - <code>first_name</code>, <code>last_name</code>, <code>age_years</code>, and <code>home</code> - with their four respective values.</p> <p>Values can be:</p> <ul> <li>character strings</li> <li>numeric (integer, floating point, or scientific representation)</li> <li>Boolean (<code>true</code> or <code>false</code>)</li> </ul> <p>or more complex nested types (see below).</p> <p>Values may be wrapped in quotation marks but be aware that this may change the way that they are interpreted i.e. <code>\"1234\"</code> will be treated as a character string, while <code>1234</code> will be treated as an integer.</p> <p>This distinction can be important,for example when describing parameters to a command. In CWL all parts of <code>baseCommand</code> must be strings so, if you want to specify a fixed numeric value to a command,make sure that you wrap that numeric value in quotes: <code>baseCommand: [echo, \"42\"]</code>.</p>"},{"location":"prerequisites/yaml/#comments","title":"Comments","text":"<p>You may use <code>#</code> to add comments to your CWL and parameter files.</p> <p>Any characters to the right of <code>#</code> will be ignored by the program interpreting the YAML.</p> <p>For example:</p> <pre><code>first_name: Bilbo\nlast_name:  Baggins\nage_years:  111\n# this line will be ignored by the interpreter\nhome:       Bag End, Hobbiton # this is ignored too\n</code></pre> <p>If there is anything on the line before the comment, be sure to add at least one space before the <code>#</code>!</p>"},{"location":"prerequisites/yaml/#maps","title":"Maps","text":"<p>When describing a tool or workflow with CWL, it is usually necessary to construct more complex, nested representations.</p> <p>Called maps, these hierarchical structures are described in YAML by providing additional key-value pairs as the value of any key.</p> <p>These pairs (sometimes referred to as \"children\") are written on new lines under the key to which they belong (the \"parent\"), and should be indented with two spaces (\u21e5tab characters are not allowed).</p> <p>For example:</p> <pre><code>cwlVersion: v1.0\nclass: CommandLineTool\nbaseCommand: echo\ninputs: # this key has an object value\n  example_flag: # so does this one\n    type: boolean\n    inputBinding: # and this one too\n      position: 1\n      prefix: -f\n</code></pre> <p>The YAML above illustrates how you can build up complex nested object descriptions relatively quickly.</p> <p>The <code>inputs</code> map contains a single key, <code>example_flag</code>, which itself contains two keys, <code>type</code> and <code>inputBinding</code>, while one of these children, <code>inputBinding</code>, contains a further two key-value pairs (<code>position</code> and <code>prefix</code>).</p> <p>See the Arrays section below for more information about providing multiple values/key-value pairs for a single key.</p> <p>For comparison with the example YAML above, here is a graphical representation of the <code>inputs</code> object it describes.</p>  graph TD   inputs --&gt; example_flag   example_flag --&gt; type   type --- bool((boolean))   example_flag --&gt; inputBinding   inputBinding --&gt; position   inputBinding --&gt; prefix   position --- posval((1))   prefix --- prefval(('-f'))"},{"location":"prerequisites/yaml/#arrays","title":"Arrays","text":"<p>In certain circumstances it is necessary to provide multiple values or objects for a single key.</p> <p>As we've already seen in the Maps section above, more than one key-value pair can be mapped to a single key.</p> <p>However, it is also possible to define multiple values for a key without having to provide a unique key for each value.</p> <p>We can achieve this with an array, where each value is defined on its own line and preceded by <code>-</code>.</p> <p>For example:</p> <pre><code>touchfiles:\n  - foo.txt\n  - bar.dat\n  - baz.txt\n</code></pre> <p>and a more complex example combining maps and arrays:</p> <pre><code>exclusive_parameters:\n  type:\n    - type: record\n      name: itemC\n      fields:\n        itemC:\n          type: string\n          inputBinding:\n            prefix: -C\n    - type: record\n      name: itemD\n      fields:\n        itemD:\n          type: string\n          inputBinding:\n            prefix: -D\n</code></pre>"},{"location":"prerequisites/yaml/#json-style","title":"JSON Style","text":"<p>YAML is based on JavaScript Object Notation (JSON) and maps and arrays can also be defined in YAML using the native JSON syntax.</p> <p>For example:</p> <pre><code>touchfiles: [foo.txt, bar.dat, baz.txt] # equivalent to first Arrays example\n</code></pre> <p>and:</p> <pre><code># equivalent to the `inputs` example in \"Maps\" above\ninputs: {example_flag: {type: boolean, inputBinding: {position: 1, prefix: -f}}}\n</code></pre> <p>Native JSON can be useful to indicate where a field is being left intentionally empty (such as <code>[]</code> for an empty array), and where it makes more sense for the values to be located on the same line (such as when providing option flags and their values in a shell command).</p> <p>However, as the second example above shows, it can severely affect the readability of a YAML file and should be used sparingly.</p>"},{"location":"prerequisites/yaml/#reference","title":"Reference","text":"<p>This page is the same as http://www.commonwl.org/user_guide/yaml/</p>"},{"location":"python-env/water_bodies/","title":"Running the step","text":""},{"location":"python-env/water_bodies/#goal","title":"Goal","text":"<p>Run the command line tool in a Python virtual environment.</p>"},{"location":"python-env/water_bodies/#lab","title":"Lab","text":"<p>This step has a dedicated lab available at <code>/workspace/quickwin/practice-labs/Application.ipynb</code></p>"},{"location":"python-env/water_bodies/#step-1-configure-the-workspace","title":"Step 1 - Configure the workspace","text":"<p>The results produced will be available in the local folder <code>/workspace/quickwin/runs</code></p> terminal<pre><code>export WORKSPACE=/workspace/quickwin\nexport RUNTIME=${WORKSPACE}/runs\nmkdir -p ${RUNTIME}\ncd ${RUNTIME}\n</code></pre>"},{"location":"python-env/water_bodies/#step-2-create-the-python-virtual-environment","title":"Step 2 - Create the Python virtual environment","text":"<p>The required Python modules are installed using <code>pip</code>:</p> terminal<pre><code>python3 -m venv env_water_bodies\nsource env_water_bodies/bin/activate\npip install --no-cache-dir rasterio click pystac loguru pyproj shapely scikit-image rio_stac\n</code></pre>"},{"location":"python-env/water_bodies/#step-3-run-the-water-bodies-detection","title":"Step 3 - Run the water bodies detection","text":"<p>The command line tool is invoked with:</p> terminal<pre><code>WORKSPACE=/workspace/quickwin\nRUNTIME=${WORKSPACE}/runs\nmkdir -p ${RUNTIME}\ncd ${RUNTIME}\n\npython \\\n    ${WORKSPACE}/water-bodies/command-line-tools/detect-water-body/app.py \\\n    --input-item \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\" \\\n    --aoi \"-121.399,39.834,-120.74,40.472\" \\\n    --epsg \"EPSG:4326\" \\\n    --band green \\\n    --band nir \n</code></pre>"},{"location":"python-env/water_bodies/#step-4-clean-up","title":"Step 4 - Clean-up","text":"<p>The Python virtual environment is no longer needed.</p> terminal<pre><code>deactivate\nrm -fr env_water_bodies\n</code></pre>"},{"location":"python-env/water_bodies/#expected-outcome","title":"Expected outcome","text":"<p>The folder <code>/workspace/quickwin/runs</code> contains: </p> <pre><code>(base) jovyan@jupyter-mrossi--training:~/quickwin/runs$ tree .\n.\n\u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A\n\u2502   \u251c\u2500\u2500 S2B_10TFK_20210713_0_L2A.json\n\u2502   \u2514\u2500\u2500 otsu.tif\n\u251c\u2500\u2500 catalog.json\n\u2514\u2500\u2500 otsu.tif\n\n1 directory, 4 files\n</code></pre>"},{"location":"reference/cwl-commandlinetool/","title":"CWL Command Line Tool Description Standard","text":"<p>The CWL Command Line Tool Description Standard specifies the document schema and execution semantics for wrapping and executing command line tools.</p> <p>Current version: CommandLineTool 1.2.0</p> <p>Previous versions:</p> <ul> <li>CommandLineTool 1.0.2</li> <li>CommandLineTool 1.1.0</li> </ul>"},{"location":"reference/cwl-workflow/","title":"CWL Workflow Description Standard","text":"<p>The CWL Workflow Description Standard specifies the document schema and execution semantics for composing workflows from components such as command line tools and other workflows.</p>"},{"location":"reference/cwltool/","title":"cwltool","text":"<p>The <code>cwltool</code> CLI reference is available at https://cwltool.readthedocs.io/en/latest/cli.html</p>"},{"location":"reference/ogc-ap-bp/","title":"OGC Application Package Best Practice","text":"<p>Published by the Open Geospatial Consortium (OGC) on January 25th 2022, the Best Practice for Earth Observation Application Package  is a guide for developers that wish to package and deploy Earth Observation (EO) Applications for a selected Exploitation Platform.</p> <p>The Best Practice for Earth Observation Application Package is available here</p>"},{"location":"release/ci/","title":"Continuous Integration","text":""},{"location":"release/ci/#application-package-software-configuration-management","title":"Application Package Software Configuration Management","text":"<p>The SCM has the task of tracking and controlling changes in the software as a part of the larger cross-disciplinary field of configuration management. </p> <p>SCM practices include revision control and the establishment of baselines.</p> <p>The Application Package code is hosted on a repository publicly accessible (Github, Bitbucket, a GitLab instance, an institutional software forge, etc.) using one of the version control systems supported by (Subversion, Mercurial and Git)</p> <p>The Application Package code include, at the top level of the source code tree, the following files:</p> <ul> <li>README containing a description of the software (name, purpose, pointers to website, documentation, development platform, contact, and support information, \u2026)</li> <li>AUTHORS, a list of all the persons to be credited for the software.</li> <li>LICENSE, the project license terms. For Open Source Licenses, the standard SPDX license names are used. For large software projects and developers, the REUSE (https://reuse.software/) process and tools can be an option to look at.</li> <li>codemeta.json, a linked data metadata file that helps index the source code in the Software Heritage archive and provides an easy way to link to other related research outputs.</li> </ul> <p>The codemeta.json includes metadata information to support the Continuous Integration phase and it is shown below:</p> codemeta.json<pre><code>{\n    \"@context\": \"https://doi.org/10.5063/schema/codemeta-2.0\",\n    \"@type\": \"SoftwareSourceCode\",\n    \"license\": \"https://spdx.org/licenses/CC-BY-NC-SA-4.0\",\n    \"codeRepository\": \"https://github.com/eoap/quickwin.git\",\n    \"dateCreated\": \"2022-09-01\",\n    \"datePublished\": \"2022-09-25\",\n    \"dateModified\": \"2022-09-25\",\n    \"name\": \"Water Bodies Detection\",\n    \"version\": \"1.1.0\",\n    \"description\": \"The Water Bodies Detection is an Application that uses the NDWI index and the Otsu threshold to detect water bodies using Sentinel-2 or Landsat-9 data\",\n    \"developmentStatus\": \"active\",\n    \"downloadUrl\": \"https://github.com/eoap/quickwin/releases/tag/1.0.0\",\n    \"relatedLink\": [\n        \"https://eoap.github.io/quickwin\"\n    ],\n    \"funder\": {\n        \"@type\": \"Organization\",\n        \"name\": \"Terradue\"\n    },\n    \"keywords\": [\n        \"NDWI\", \"Landsat-9\", \"Sentinel-2\", \"Water Bodies\"\n    ],\n    \"programmingLanguage\": [\n        \"Python\", \"CWL\"\n    ],\n    \"softwareRequirements\": [\n        \"container runtime\",\n        \"cwl runner\"\n    ],\n    \"author\": [\n        {\n            \"@type\": \"Person\",\n            \"givenName\": \"Jane\",\n            \"familyName\": \"Doe\",\n            \"email\": \"jane.doe@acme.earth\",\n            \"affiliation\": {\n                \"@type\": \"Organization\",\n                \"name\": \"ACME\"\n            }\n        },\n        {\n            \"@type\": \"Person\",\n            \"givenName\": \"John\",\n            \"familyName\": \"Doe\",\n            \"email\": \"john.doe@acme.earth\",\n            \"affiliation\": {\n                \"@type\": \"Organization\",\n                \"name\": \"ACME\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"release/ci/#application-package-continuous-integration","title":"Application Package Continuous Integration","text":"<p>A typical Continuous Integration scenario for an Application Package includes the release of the CWL document(s) and publishing the container images to a container registry.</p> <p>This is depicted below: </p> graph TB SCM[(software repository)] SCM -- CWL Workflow --&gt; A SCM -- codemeta.json --&gt; B A(validate CWL Workflow) --&gt; B(extract version) B --&gt; C subgraph Build containers SCM -- Dockerfiles --&gt; C C(build container) --&gt; D(push container)  end D -- push --&gt; CR[(Container Registry)]  D -- container sha256 --&gt; F(\"update Dockerpull/metadata in CWL Workflows\")  F -- push --&gt; AR[(Artifact Registry)] SCM -- codemeta.json --&gt; F <p>Below an example of a GitHub CI configuration implementing the scenario:</p> .github/workflows/build.yaml<pre><code>name: build\non:\n  push:\n    branches:\n    - master\n    - main\n    - bids23\n\n    paths:\n    # Only rebuild website when apps have changed\n    - 'water-bodies/**'\n    - .github/**\n    - docs/**\n    - cwl-workflow/*.cwl\n    - codemeta.json\n    - practice-labs/**\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: actions/setup-python@v2\n      with:\n        python-version: 3.x\n    - run: pip install cwltool\n    - run: cwltool --validate cwl-workflow/app-water-body-cloud-native.cwl\n\n  version:\n    needs: validate\n\n    runs-on: ubuntu-latest\n\n    outputs:\n\n      app-version: ${{ steps.set-version.outputs.version }}\n\n    steps:\n    - uses: actions/checkout@v2\n    - run: echo \"APP_VERSION=$(cat codemeta.json | jq -r .version )\" &gt;&gt; $GITHUB_ENV\n    - run: echo app version is $APP_VERSION\n    - id: set-version\n      run: echo \"::set-output name=version::$APP_VERSION\"\n\n  container-build:\n\n    needs: version\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2   \n    - run: echo version ${{needs.version.outputs.app-version}}\n    - run: echo \"${{ secrets.GITHUB_TOKEN }}\" | docker login ghcr.io -u ${{ github.actor }} --password-stdin\n    - name: build &amp; push image\n      run: |\n        IMAGE_ID=ghcr.io/eoap/quickwin/detect-water-body\n        docker build water-bodies/command-line-tools/detect-water-body --file water-bodies/command-line-tools/detect-water-body/Dockerfile --tag detect-water-body\n        docker tag detect-water-body $IMAGE_ID:${{needs.version.outputs.app-version}}\n        docker push $IMAGE_ID:${{needs.version.outputs.app-version}}\n\n  create-release:\n\n    needs:\n    - container-build\n    - version\n\n    runs-on: ubuntu-latest\n\n    outputs:\n\n      upload_url: ${{ steps.set-upload-url.outputs.upload_url }}\n\n    steps:\n      - name: release\n        uses: actions/create-release@v1\n        id: create_release\n        with:\n          draft: false\n          prerelease: false\n          release_name: ${{needs.version.outputs.app-version}}\n          tag_name: ${{needs.version.outputs.app-version}}\n        env:\n          GITHUB_TOKEN: ${{ github.token }}\n      - id: set-upload-url\n        run: echo \"::set-output name=upload_url::${{ steps.create_release.outputs.upload_url }}\"\n\n  publish-artifacts:\n\n    needs:\n    - create-release\n    - version\n\n    runs-on: ubuntu-latest\n\n    steps:   \n    - uses: actions/checkout@v2 \n    - run: |\n\n        tag=\"ghcr.io/eoap/quickwin/detect-water-body:${{needs.version.outputs.app-version}}\"\n        docker pull ${tag}\n        shatag=$( docker inspect ${tag} | yq -r '.[0][\"RepoDigests\"][0]' )\n        s=\"detect-water-body\" t=\"${shatag}\" yq -i eval '(.$graph[] | select (.id == env(s)) ).hints.DockerRequirement.dockerPull = env(t)' cwl-workflow/app-water-body-cloud-native.cwl\n\n    - run: |\n        r=$( cat codemeta.json | jq -r \".codeRepository\" ) yq -i eval '.\"s:codeRepository\" = {\"URL\" : env(r)}' cwl-workflow/app-water-body-cloud-native.cwl\n        v=\"${{needs.version.outputs.app-version}}\" yq -i eval '.\"s:softwareVersion\" = env(v)' cwl-workflow/app-water-body-cloud-native.cwl\n        n=$(cat codemeta.json | jq -r '(.author[0].givenName + \" \" + .author[0].familyName)') \\\n        e=$(cat codemeta.json | jq -r '.author[0].email') \\\n        a=$(cat codemeta.json | jq -r '.author[0].affiliation[\"name\"]') \\\n        yq eval -i  '.\"s:author\" += [{\"class\": \"s:Person\", \"s.name\": env(n), \"s.email\": env(e), \"s.affiliation\": env(a)}]' cwl-workflow/app-water-body-cloud-native.cwl\n    - run: |\n        mkdir downloads\n        cp cwl-workflow/app-water-body-cloud-native.cwl downloads/app-water-body-cloud-native.${{needs.version.outputs.app-version}}.cwl\n    - uses: actions/upload-artifact@v4\n      with:\n        name: application-package\n        path: downloads\n    - name: upload linux artifact 1\n      uses: actions/upload-release-asset@v1\n      env:\n        GITHUB_TOKEN: ${{ github.token }}\n      with:\n        upload_url: ${{needs.create-release.outputs.upload_url}}\n        asset_path: downloads/app-water-body-cloud-native.${{needs.version.outputs.app-version}}.cwl\n        asset_name: app-water-body-cloud-native.${{needs.version.outputs.app-version}}.cwl\n        asset_content_type: text/yaml\n</code></pre>"},{"location":"release/ci/#artefacts","title":"Artefacts","text":"<p>The released application package is published here: https://github.com/eoap/quickwin/releases/tag/1.0.0</p> <p>The container is available at: https://github.com/eoap/quickwin/pkgs/container/quickwin%2Fdetect-water-body</p>"},{"location":"release/scope/","title":"Scope","text":"<p>Releasing an Application Package targets:</p> <ul> <li> <p>building and pushing the container images to a container registry</p> </li> <li> <p>updating the Application Package to reference these container images </p> </li> <li> <p>pushing the updated Application Package to an artifact repository</p> </li> </ul>"}]}